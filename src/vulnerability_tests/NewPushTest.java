package vulnerability_tests;

import device.DeviceInfo;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import util.Command;
import util.Config;
import util.Util;
import vulerability.VulnerabilityInfo;
import vulerability.VulnerabilityTestResult;

import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;

public class NewPushTest implements VulnerabilityTest {
    private Command command = new Command();
    public static volatile boolean exitSignal = false;
    public static volatile boolean exitReady = false;
    public static volatile boolean running = false;
    public static String deviceID = "";
    public static boolean showAllResults = false;
    String localfilePath =System.getProperty("user.dir");
    String pocPath = "";


    @Override
    public VulnerabilityTestResult testResult(VulnerabilityInfo vulnerability, DeviceInfo deviceInfo) {
        return null;
    }

    public ArrayList<VulnerabilityTestResult> pushAndTest(VulnerabilityInfo[] vulnerabilities, DeviceInfo deviceInfo){
        running = true;
        if(!getPocPath(deviceInfo)) {
            Util.errorOutput(Config.DEVICE_ARCHITECTURE_NOT_SUPPORTED_ERROR);
            return null;
        }
        command.buildPocPath();
        ArrayList<VulnerabilityInfo> pushedPocs = new ArrayList<>();
        ArrayList<VulnerabilityTestResult> testResultsList = new ArrayList<>();
        int pushedSize = 0;
        for(int i = 0; i < vulnerabilities.length && !exitSignal; i++){
            VulnerabilityInfo vul = vulnerabilities[i];
            if(!pushPoc(vul)) continue;
            else {
                pushedPocs.add(vul);
                pushedSize ++;
            }
            Util.testOutput("Testing " + vul.getCveId());

            // 执行poc
            HashMap<String, ArrayList<String>> resMap = command.runPoc(vul);
            if(analyzeConnectionResMap(resMap)){
                command.kill();
                Util.recoverOutput("Lost Connection. Recovering...");
                if(pushedPocs.get(pushedSize - 2).getParticularOutcome() != Config.PARTICULAR_OUTCOME_NONE){
                    testResultsList.remove(testResultsList.size() - 1);
                    pushedPocs.remove(pushedSize - 1);
                    pushedSize --;
                    testResultsList.add(new VulnerabilityTestResult(pushedPocs.get(pushedSize - 1), true, null));
                }
                if(command.recoverFromReboot()) {
                    i --;
                    command.buildPocPath();
                    continue;
                }
                else {
                    Util.errorOutput(Config.RECOVER_FAILED);
                    return testResultsList;
                }
            } else {
                ArrayList<String> inList = resMap.get("in");
                int res = judge(inList.get(inList.size() - 1), vul.getIsVulnerality());
                if(res == 0) testResultsList.add(new VulnerabilityTestResult(vul, true, null));
                else if(showAllResults) {
                    if(res == 1) testResultsList.add(new VulnerabilityTestResult(vul, false, null));
                    else if(res == -1) testResultsList.add(new VulnerabilityTestResult(vul, false, new Exception()));
                }
                Util.testOutput(vul.getPocName() + " test ended.");
                Util.testOutput("Exit with " + res);
                System.out.println();
            }
        }
//        } else {
//            logger.info(Config.COPY_ERROR);
//            return null;
//        }
        command.cleanPocPaths();
        return testResultsList;
    }

    private boolean getPocPath(DeviceInfo deviceInfo){
        String cpuabi=deviceInfo.buildCpuABI;
        String cpuabi2=deviceInfo.buildCpuABI2;
        if(cpuabi.contains("armeabi-v7a") || cpuabi2.contains("armeabi-v7a")) {
            pocPath = localfilePath+ File.separator+"cases"+File.separator+"armeabi-v7a"+File.separator;
        }else if (cpuabi.contains("arm64-v8a") || cpuabi2.contains("arm64-v8a")) {
            pocPath = localfilePath+File.separator+"cases"+File.separator+"arm64-v8a"+File.separator;
        }else if (cpuabi.equals("x86") || cpuabi2.equals("x86")) {
            pocPath = localfilePath+File.separator+"cases"+File.separator+"x86"+File.separator;
        }else if (cpuabi.equals("x86_64") || cpuabi2.equals("x86_64")) {
            pocPath = localfilePath+File.separator+"cases"+File.separator+"x86_64"+File.separator;
        }else {
            //设备架构不支持，直接返回结果
            Util.errorOutput("Device architecture is not supported");
            return false;
        }
        return true;
    }

    private boolean pushPoc(VulnerabilityInfo vul){
        Command command = new Command();
        String pocLocation = pocPath + vul.getPocName();
        File file = new File(pocLocation);
        if(!file.exists()){
            Util.testOutput("Architecture does not match " + vul.getPocName() + ", pass.");
            System.out.println();
            return false;
        }
        command.pushFile(pocLocation, Config.FINAL_POC_LOCATION);
        String permission= Command.adbCommand + " chmod +x " + Config.FINAL_POC_LOCATION + vul.getPocName();
        command.runCommand(permission);
        return true;
    }


    private int judge(String res, HashMap<String, String> isVul){
        if(res.equals(isVul.get("Vulnerable"))) return 0;
        if(res.equals(isVul.get("Not Vulnerable"))) return 1;
        return -1;
    }

    private boolean analyzeConnectionResMap(HashMap<String, ArrayList<String>> resMap){
        // error: device 'FA68K0310186' not found
        ArrayList<String> inList = resMap.get("in");
        ArrayList<String> errList = resMap.get("err");
        ArrayList<String> failList = resMap.get("fail");
        for(int i = 0; i < inList.size() - 1; i++) {
            if(inList.get(i).contains("no devices/emulators") ||
                    (inList.get(i).contains("device") && inList.get(i).contains("not found")))
                return true;
        }
        for(String s : errList) if(s.contains("no devices/emulators") ||
                (s.contains("device") && s.contains("not found"))) return true;
        for(String s : failList) if(s.contains("no devices/emulators") ||
                (s.contains("device") && s.contains("not found"))) return true;
        return false;
    }
}
